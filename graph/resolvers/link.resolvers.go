package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.46

import (
	"context"
	"fmt"
	"log"
	"time"

	"github.com/RouteHub-Link/DomainUtils/validator"
	"github.com/RouteHub-Link/routehub-service-graphql/auth"
	database_enums "github.com/RouteHub-Link/routehub-service-graphql/database/enums"
	database_models "github.com/RouteHub-Link/routehub-service-graphql/database/models"
	database_types "github.com/RouteHub-Link/routehub-service-graphql/database/types"
	"github.com/RouteHub-Link/routehub-service-graphql/graph"
	"github.com/RouteHub-Link/routehub-service-graphql/graph/model"
	services_domain_utils "github.com/RouteHub-Link/routehub-service-graphql/services/domain_utils"
	"github.com/RouteHub-Link/routehub-service-graphql/worker"
	"github.com/cloudmatelabs/gorm-gqlgen-relay/relay"
	"github.com/google/uuid"
	"github.com/vektah/gqlparser/gqlerror"
)

// Creator is the resolver for the creator field.
func (r *linkResolver) Creator(ctx context.Context, obj *database_models.Link) (*database_models.User, error) {
	return r.LoaderContainer.User.Get(ctx, obj.CreatedBy)
}

// Domain is the resolver for the domain field.
func (r *linkResolver) Domain(ctx context.Context, obj *database_models.Link) (*database_models.Domain, error) {
	return r.ServiceContainer.DomainService.GetDomainByPlatformId(obj.PlatformID)
}

// Analytics is the resolver for the analytics field.
func (r *linkResolver) Analytics(ctx context.Context, obj *database_models.Link) ([]*model.MetricAnalytics, error) {
	mock := []*model.MetricAnalytics{
		{
			Feeder:       "Not Implemented (Mock)",
			TotalHits:    300,
			TotalSuccess: 123,
			TotalFailed:  177,
			StartAt:      time.Now().Add(-time.Hour * (24 * 3)),
			EndAt:        time.Now(),
		},
		{
			Feeder:       "Facebook (Mock)",
			TotalHits:    100,
			TotalSuccess: 50,
			TotalFailed:  50,
			StartAt:      time.Now().Add(-time.Hour * (24 * 7)),
			EndAt:        time.Now(),
		},
		{
			Feeder:       "X (Mock)",
			TotalHits:    300,
			TotalSuccess: 200,
			TotalFailed:  100,
			StartAt:      time.Now().Add(-time.Hour * (12 * 7)),
			EndAt:        time.Now(),
		}}
	return mock, nil
}

// OpenGraph is the resolver for the openGraph field.
func (r *linkResolver) OpenGraph(ctx context.Context, obj *database_models.Link) ([]*database_types.OpenGraph, error) {
	return []*database_types.OpenGraph{obj.OpenGraph}, nil
}

// RedirectionOptions is the resolver for the redirectionOptions field.
func (r *linkResolver) RedirectionOptions(ctx context.Context, obj *database_models.Link) (database_enums.RedirectionOptions, error) {
	return obj.RedirectionChoice, nil
}

// Validations is the resolver for the validations field.
func (r *linkResolver) Validations(ctx context.Context, obj *database_models.Link) ([]*database_models.LinkValidation, error) {
	return r.ServiceContainer.LinkValidationService.GetLinkValidationsByLinkId(obj.ID)
}

// LastValidation is the resolver for the lastValidation field.
func (r *linkResolver) LastValidation(ctx context.Context, obj *database_models.Link) (*database_models.LinkValidation, error) {
	return r.ServiceContainer.LinkValidationService.GetLinkValidationByLinkId(obj.ID)
}

// Crawls is the resolver for the crawls field.
func (r *linkResolver) Crawls(ctx context.Context, obj *database_models.Link) ([]*database_models.LinkCrawl, error) {
	return r.ServiceContainer.LinkService.GetCrawls(obj.ID)
}

// Link is the resolver for the link field.
func (r *linkCrawlResolver) Link(ctx context.Context, obj *database_models.LinkCrawl) (*database_models.Link, error) {
	return r.ServiceContainer.LinkService.GetLinkById(obj.LinkId)
}

// CrawledBy is the resolver for the crawledBy field.
func (r *linkCrawlResolver) CrawledBy(ctx context.Context, obj *database_models.LinkCrawl) (*database_models.User, error) {
	return r.LoaderContainer.User.Get(ctx, obj.CreatedBy)
}

// CreatedBy is the resolver for the createdBy field.
func (r *linkValidationResolver) CreatedBy(ctx context.Context, obj *database_models.LinkValidation) (*database_models.User, error) {
	panic(fmt.Errorf("not implemented: CreatedBy - createdBy"))
}

// CreateLink is the resolver for the createLink field.
func (r *mutationResolver) CreateLink(ctx context.Context, input model.LinkCreateInput) (*database_models.Link, error) {
	userSession := auth.ForContext(ctx)
	if userSession == nil {
		return nil, gqlerror.Errorf("Access Denied")
	}

	log.Printf("CreateLink: %+v", input)

	var _validator = validator.DefaultValidator()
	isValid, err := _validator.ValidateURL(input.Target)

	if !isValid || err != nil {
		gqlError := gqlerror.Errorf("Invalid URL")
		if err != nil {
			gqlError = gqlerror.Errorf("Invalid URL %s", err.Error())
		}
		return nil, gqlError
	}

	payload := services_domain_utils.SiteValidationPayload{Link: input.Target}
	validationTaskId, err := r.ServiceContainer.DomainUtilsService.PostValidateSite(&payload)
	if err != nil {
		return nil, gqlerror.Errorf("Process Failed %s", err.Error())
	}

	validationTaskUUID, err := uuid.Parse(validationTaskId)
	if err != nil {
		return nil, gqlerror.Errorf("ID: %s Process Failed %s", validationTaskId, err.Error())
	}

	link, err := r.ServiceContainer.LinkService.CreateLink(input, userSession.ID, validationTaskUUID)
	if err != nil {
		return nil, gqlerror.Errorf("Process Failed %s", err.Error())
	}

	_, err = r.ServiceContainer.LinkValidationService.Validate(userSession.ID, link)
	if err != nil {
		return nil, gqlerror.Errorf("Process Failed %s", err.Error())
	}

	//_, err := r.ServiceContainer.LinkService.SaveCrawlRequest(link, userSession.ID)
	//if err != nil {
	//	return nil, gqlerror.Errorf("Process Failed %s", err.Error())
	//}

	// subscribe to the crawl request and start the process
	//_, e := r.ServiceContainer.WorkerService.NewCrawlURL(worker.CrawlURLPayload{LinkId: link.ID, CrawlId: crawlId, LinkUrl: link.Target})
	//if e != nil {
	//	return nil, gqlerror.Errorf("Process Failed %s", e.Error())
	//}

	return link, nil
}

// RequestCrawl is the resolver for the requestCrawl field.
func (r *mutationResolver) RequestCrawl(ctx context.Context, input model.CrawlRequestInput) (*database_models.LinkCrawl, error) {
	userSession := auth.ForContext(ctx)
	if userSession == nil {
		return nil, gqlerror.Errorf("Access Denied")
	}

	link, err := r.ServiceContainer.LinkService.GetLinkById(input.LinkID)
	if err != nil {
		return nil, gqlerror.Errorf("Process Failed %s", err.Error())
	}

	validation, err := r.ServiceContainer.LinkValidationService.GetLinkValidationByLink(link)
	if err != nil {
		return nil, gqlerror.Errorf("Process Failed %s", err.Error())
	}

	if validation.CompletedAt == nil {
		return nil, gqlerror.Errorf("Validation is not completed crawling is not allowed for unvalidated links!")
	}

	crawlId, err := r.ServiceContainer.LinkService.SaveCrawlRequest(link, userSession.ID)
	if err != nil {
		return nil, gqlerror.Errorf("Process Failed %s", err.Error())
	}

	e := r.ServiceContainer.WorkerService.NewCrawlURL(worker.CrawlURLPayload{LinkId: input.LinkID, CrawlId: crawlId, LinkUrl: link.Target})
	if e != nil {
		return nil, gqlerror.Errorf("Process Failed %s", e.Error())
	}

	crawls, err := r.ServiceContainer.LinkService.GetCrawls(link.ID)

	return crawls[len(crawls)-1], err
}

// AddToPinnedLinks is the resolver for the addToPinnedLinks field.
func (r *mutationResolver) AddToPinnedLinks(ctx context.Context, input model.PinnedLinkInput) (*database_models.Link, error) {
	link, err := r.ServiceContainer.LinkService.GetLinkById(input.LinkID)
	if err != nil {
		return nil, gqlerror.Errorf("Process Failed %s", err.Error())
	}

	userSession := auth.ForContext(ctx)
	err = r.ServiceContainer.LinkService.AddToPinnedLinks(link.PlatformID, link.ID, userSession.ID)
	if err != nil {
		return nil, gqlerror.Errorf("Process Failed %s", err.Error())
	}

	return link, nil
}

// RemoveFromPinnedLinks is the resolver for the removeFromPinnedLinks field.
func (r *mutationResolver) RemoveFromPinnedLinks(ctx context.Context, input model.PinnedLinkInput) (*database_models.Link, error) {
	link, err := r.ServiceContainer.LinkService.GetLinkById(input.LinkID)
	if err != nil {
		return nil, gqlerror.Errorf("Process Failed %s", err.Error())
	}

	err = r.ServiceContainer.LinkService.RemoveFromPinnedLinks(link.PlatformID, link.ID)
	if err != nil {
		return nil, gqlerror.Errorf("Process Failed %s", err.Error())
	}

	return link, nil
}

// Links is the resolver for the links field.
func (r *queryResolver) Links(ctx context.Context, first *int, after *string, last *int, before *string, orderBy map[string]interface{}, where *model.LinkFilter) (*relay.Connection[database_models.Link], error) {
	linkName := database_models.Link{}.TableName()

	// If the cursor is "<uuid.UUID Value>" Check this link ; https://github.com/cloudmatelabs/gorm-gqlgen-relay/pull/2
	return relay.Paginate[database_models.Link](r.DB, where, orderBy, relay.PaginateOption{
		First:      first,
		After:      after,
		Last:       last,
		Before:     before,
		Table:      linkName,
		PrimaryKey: "id",
	})
}

// Link returns graph.LinkResolver implementation.
func (r *Resolver) Link() graph.LinkResolver { return &linkResolver{r} }

// LinkCrawl returns graph.LinkCrawlResolver implementation.
func (r *Resolver) LinkCrawl() graph.LinkCrawlResolver { return &linkCrawlResolver{r} }

// LinkValidation returns graph.LinkValidationResolver implementation.
func (r *Resolver) LinkValidation() graph.LinkValidationResolver { return &linkValidationResolver{r} }

// Query returns graph.QueryResolver implementation.
func (r *Resolver) Query() graph.QueryResolver { return &queryResolver{r} }

type linkResolver struct{ *Resolver }
type linkCrawlResolver struct{ *Resolver }
type linkValidationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
